<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>FLTK Dock: fltk::Window Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<b>fltk</b>::<a class="el" href="classfltk_1_1Window.html">Window</a></div>
<h1>fltk::Window Class Reference</h1><!-- doxytag: class="fltk::Window" --><!-- doxytag: inherits="fltk::Group" -->Inheritance diagram for fltk::Window:<p><center><img src="classfltk_1_1Window__inherit__graph.png" border="0" usemap="#fltk_1_1Window__inherit__map" alt="Inheritance graph"></center>
<map name="fltk_1_1Window__inherit__map">
<area href="classfltk_1_1Group.html" shape="rect" coords="17,156,100,180" alt="">
<area href="classfltk_1_1Widget.html" shape="rect" coords="15,81,103,105" alt="">
<area href="classfltk_1_1Rectangle.html" shape="rect" coords="5,7,112,31" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center>Collaboration diagram for fltk::Window:<p><center><img src="classfltk_1_1Window__coll__graph.png" border="0" usemap="#fltk_1_1Window__coll__map" alt="Collaboration graph"></center>
<map name="fltk_1_1Window__coll__map">
<area href="classfltk_1_1Group.html" shape="rect" coords="145,16,228,40" alt="">
<area href="classfltk_1_1Widget.html" shape="rect" coords="252,121,340,145" alt="">
<area href="classfltk_1_1Rectangle.html" shape="rect" coords="325,16,432,40" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="classfltk_1_1Window-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#91eac5daeb707e10683d6673a4da40e3">Window</a> (int, int, int, int, const char *=0, bool begin=false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#25871ce0f0a1b91b94a365f96712aec4">Window</a> (int, int, const char *=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#245d821e6016fa1f6970ccbbedd635f6">~Window</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#4c27350d7dc01d2afe45739e5b0fb4d4">label</a> (const char *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#f8ee0dd02ba228e8e6170d2a4217ed18">iconlabel</a> (const char *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#5c8bd6c3b608acb572110518143278a9">copy_label</a> (const char *c)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#9c13181da2aaa86d64d97c196a6d068e">child_of</a> (const <a class="el" href="classfltk_1_1Window.html">Window</a> *w)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#cebc7726c5966f1b32686aa90312416d">double_buffer</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#d91da0a0939943723a27ca2bd4672627">set_double_buffer</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#97938567f621fef7ae186a9d925a22f9">clear_double_buffer</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#3e4c48e061072f4a71212dcb5b7f606d">draw_overlay</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#d0c83f563ac13bb59a88f0e82a7144f9">redraw_overlay</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#054bedf0b81483179f715b1a60ccc553">erase_overlay</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#de0132a93387e62212ce3cb0bc419682">size_range</a> (int a, int b, int c=0, int d=0, int e=0, int f=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#d7f0f1bcbb151182a5ec9944f766d8d5">shown</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#8f986e19a11c4c97ed8e6ad3d0e648b7">show</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#254f7246f0e788485d951758ff22660e">show</a> (const <a class="el" href="classfltk_1_1Window.html">Window</a> *parent)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#b79e6f93410599b39e0aa685e64cbc56">exec</a> (const <a class="el" href="classfltk_1_1Window.html">Window</a> *parent=0, bool grab=false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#bb62d38f4a880bdc884a3434b7a82bbe">make_exec_return</a> (bool)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#acf539860caedce0c1c3e02b8b4c9181">show_inside</a> (const <a class="el" href="classfltk_1_1Window.html">Window</a> *parent)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#a89262ad2538473c8d7e4d8dd641849d">destroy</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#6ce31a8f940610315a678b4d9b9041c5">handle</a> (int)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#b93968c0acfba057731631d87dbfffb8">layout</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#2ec96f7b1e29635e7a7bff479697ecf9">draw</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#42b2a99d60c2024df83bac61eb756197">borders</a> (<a class="el" href="classfltk_1_1Rectangle.html">Rectangle</a> *r) const </td></tr>

<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static NamedStyle *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfltk_1_1Window.html#5285934f97d4416b5f6d7efd62982bff">default_style</a> = &amp;::style</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This widget produces an actual window. This can either be a main window, with a border and title and all the window management controls, or a "subwindow" inside a window. This is controlled by whether or not the window has a <a class="el" href="classfltk_1_1Widget.html#afcfed60392799ab3bd7124e2c707575">parent()</a>. Internally there are now significant differences between "main" windows and "subwindows" and these really should be different classes, they are the same for historic fltk reasons.<p>
Once you create a window, you usually add children Widgets to it by using add(child) or by using <a class="el" href="classfltk_1_1Group.html#cc8de5563f6f88be0b1a69549ab58f00">begin()</a> and then constructing the children. See <a class="el" href="classfltk_1_1Group.html">fltk::Group</a> for more information on how to add and remove children.<p>
There are several subclasses of <a class="el" href="classfltk_1_1Window.html">fltk::Window</a> that provide double-buffering, overlay, menu, and OpenGL support.<p>
The window's callback is done if the user tries to close a window using the window manager and fltk::modal() is zero or equal to the window. <a class="el" href="classfltk_1_1Window.html">Window</a> has a default callback that calls <a class="el" href="classfltk_1_1Widget.html#4a2f8eebacdd20db505b838f1a118c6b">Window::hide()</a> and calls exit(0) if this is the last top-level window.<p>
You can set the shortcut() and then that key will call the callback. If you don't change it then that key will close the window. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="91eac5daeb707e10683d6673a4da40e3"></a><!-- doxytag: member="fltk::Window::Window" ref="91eac5daeb707e10683d6673a4da40e3" args="(int, int, int, int, const char *=0, bool begin=false)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">Window::Window           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Y</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>W</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>H</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>l</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>begin</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This constructor is for <em>child</em> windows. You should use the constructor with just W and H for normal parent windows. This constructor leaves visible() true, so the child window will appear when the parent window has <a class="el" href="classfltk_1_1Window.html#8f986e19a11c4c97ed8e6ad3d0e648b7">show()</a> called.     </td>
  </tr>
</table>
<a class="anchor" name="25871ce0f0a1b91b94a365f96712aec4"></a><!-- doxytag: member="fltk::Window::Window" ref="25871ce0f0a1b91b94a365f96712aec4" args="(int, int, const char *=0)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">Window::Window           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>W</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>H</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>l</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This form of the constructor should be used for a "top-level" window (that is, one that is not inside another window). It correctly sets visible() to false and <a class="el" href="classfltk_1_1Widget.html#afcfed60392799ab3bd7124e2c707575">parent()</a> to NULL. By not specifying the position of the window, the window system will pick a place to show the window (some older X window managers will allow the user to place the window by hand). If you want to force a position you should call position(x,y) or hotspot() before calling <a class="el" href="classfltk_1_1Window.html#8f986e19a11c4c97ed8e6ad3d0e648b7">show()</a>.     </td>
  </tr>
</table>
<a class="anchor" name="245d821e6016fa1f6970ccbbedd635f6"></a><!-- doxytag: member="fltk::Window::~Window" ref="245d821e6016fa1f6970ccbbedd635f6" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">Window::~Window           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calls <a class="el" href="classfltk_1_1Window.html#a89262ad2538473c8d7e4d8dd641849d">destroy()</a>. The destructor <em>also deletes all the children</em>. This allows a whole tree to be deleted at once, without having to keep a pointer to all the children in the user code. A kludge has been done so the <a class="el" href="classfltk_1_1Window.html">Window</a> and all of it's children can be automatic (local) variables, but you must declare the <a class="el" href="classfltk_1_1Window.html">Window</a> first so that it is destroyed last.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="42b2a99d60c2024df83bac61eb756197"></a><!-- doxytag: member="fltk::Window::borders" ref="42b2a99d60c2024df83bac61eb756197" args="(Rectangle *r) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Window::borders           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classfltk_1_1Rectangle.html">Rectangle</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>r</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classfltk_1_1Rectangle.html">Rectangle</a> is set to the the size of the borders that will be added around this window. This is done by querying the window system. Because it is more convienent for most code the result is actually the rectangle that would be around the border if this window was zero in size and placed at 0,0. x,y are typically negative and w,h are typically positive. To get the actual rectangle around your window, add these values to the window's size.     </td>
  </tr>
</table>
<a class="anchor" name="9c13181da2aaa86d64d97c196a6d068e"></a><!-- doxytag: member="fltk::Window::child_of" ref="9c13181da2aaa86d64d97c196a6d068e" args="(const Window *w)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Window::child_of           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classfltk_1_1Window.html">Window</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>parent</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Tell the system that this window will not have an icon, it will dissappear and reappear when <em>parent</em> is iconized or shown, and it is forced to always be above <em>parent</em>. On X this is called a "Transient window", and Windows calls this a "overlapping child". <em>parent</em> is different than the <a class="el" href="classfltk_1_1Widget.html#afcfed60392799ab3bd7124e2c707575">parent()</a>, which must be zero.<p>
Changing this value causes <a class="el" href="classfltk_1_1Window.html#a89262ad2538473c8d7e4d8dd641849d">destroy()</a> to be called, due to stupid limitations in X and Windows.<p>
Win32 and some X window managers have an annoying bug where calling <a class="el" href="classfltk_1_1Window.html#8f986e19a11c4c97ed8e6ad3d0e648b7">show()</a> on this will also raise the parent window to right below this, making many useful user interface designs impossible!<p>
If you want a dialog that blocks interaction with the other windows of your application or with all other applications, you need to look at <a class="el" href="classfltk_1_1Window.html#b79e6f93410599b39e0aa685e64cbc56">exec()</a> (or possibly fltk::modal()).     </td>
  </tr>
</table>
<a class="anchor" name="97938567f621fef7ae186a9d925a22f9"></a><!-- doxytag: member="fltk::Window::clear_double_buffer" ref="97938567f621fef7ae186a9d925a22f9" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Window::clear_double_buffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Turn off double buffering, so that drawing directly goes to the visible image on the screen. Not all systems can do this, they will remain double buffered even if this is off.     </td>
  </tr>
</table>
<a class="anchor" name="5c8bd6c3b608acb572110518143278a9"></a><!-- doxytag: member="fltk::Window::copy_label" ref="5c8bd6c3b608acb572110518143278a9" args="(const char *c)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void fltk::Window::copy_label           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>c</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the label to a copy of the string. The passed string is copied to private storage and used to set the label(). The memory will be freed when the widget is destroyed or when <a class="el" href="classfltk_1_1Window.html#5c8bd6c3b608acb572110518143278a9">copy_label()</a> is called again, or <a class="el" href="classfltk_1_1Window.html#4c27350d7dc01d2afe45739e5b0fb4d4">label(const char*)</a> is called.<p>
Passing NULL will set label() to NULL. 
<p>
Reimplemented from <a class="el" href="classfltk_1_1Widget.html#a57ffdb237a9cbbe00317ffd3b18c41c">fltk::Widget</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a89262ad2538473c8d7e4d8dd641849d"></a><!-- doxytag: member="fltk::Window::destroy" ref="a89262ad2538473c8d7e4d8dd641849d" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Window::destroy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Hides the window and also deletes all window system information about the window, and thus returns it back to the state it was in before the first <a class="el" href="classfltk_1_1Window.html#8f986e19a11c4c97ed8e6ad3d0e648b7">show()</a>. It is harmless to call this if the window is already destroyed.<p>
Subclasses can override this, if you do this you must also override the destructor and make it call <a class="el" href="classfltk_1_1Window.html#a89262ad2538473c8d7e4d8dd641849d">destroy()</a>.     </td>
  </tr>
</table>
<a class="anchor" name="cebc7726c5966f1b32686aa90312416d"></a><!-- doxytag: member="fltk::Window::double_buffer" ref="cebc7726c5966f1b32686aa90312416d" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool Window::double_buffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns true if <a class="el" href="classfltk_1_1Window.html#d91da0a0939943723a27ca2bd4672627">set_double_buffer()</a> was called, returns false if <a class="el" href="classfltk_1_1Window.html#97938567f621fef7ae186a9d925a22f9">clear_double_buffer()</a> was called. If neither has been called this returns a machine-dependent state (systems where double buffering is efficient turn it on by default).     </td>
  </tr>
</table>
<a class="anchor" name="2ec96f7b1e29635e7a7bff479697ecf9"></a><!-- doxytag: member="fltk::Window::draw" ref="2ec96f7b1e29635e7a7bff479697ecf9" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Window::draw           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fltk calls this virtual function to draw the widget, after setting up the graphics (current window, xy translation, etc) so that any drawing functions will go into this widget.<p>
User code should not call this! You probably want to call <a class="el" href="group__damage.html#g32a4160211702f375d7160d5a687cad4">redraw()</a>.<p>
The default version calls draw_box() and draw_label(), thus drawing the box() to fill the widget and putting the label() and <a class="el" href="classfltk_1_1Widget.html#f6b53e8e41f1c00a095e9f66b5b23910">image()</a> inside it to fill it, unless the align() flags are set to put it outside.<p>
Information on how to write your own version is <a href="subclassing.html#draw>" 
>here</a>. 
<p>
Reimplemented from <a class="el" href="classfltk_1_1Group.html#b1c77e39884a17637d05df7ab277fb0d">fltk::Group</a>.    </td>
  </tr>
</table>
<a class="anchor" name="3e4c48e061072f4a71212dcb5b7f606d"></a><!-- doxytag: member="fltk::Window::draw_overlay" ref="3e4c48e061072f4a71212dcb5b7f606d" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Window::draw_overlay           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A subclass of <a class="el" href="classfltk_1_1Window.html">Window</a> can define this method to draw an "overlay" image that appears atop everything else in the window. This will only be called if you call <a class="el" href="classfltk_1_1Window.html#d0c83f563ac13bb59a88f0e82a7144f9">redraw_overlay()</a> on the <a class="el" href="classfltk_1_1Window.html#d7f0f1bcbb151182a5ec9944f766d8d5">shown()</a> window, and it will stop being called if you call <a class="el" href="classfltk_1_1Window.html#054bedf0b81483179f715b1a60ccc553">erase_overlay()</a>.<p>
This is designed for a fast-changing graphic such as a selection rectangle. The implementation is to put the window into <a class="el" href="classfltk_1_1Window.html#cebc7726c5966f1b32686aa90312416d">double_buffer()</a> mode, and then set things so the on-screen image is being drawn before this method is called. The previous overlay image was erased before calling this by copying the back buffer to the front. Notice that the overlay will blink as you redraw it, you must trade off this annoyance against the slower update of the overlay if you just draw it normally in the <a class="el" href="classfltk_1_1Window.html#2ec96f7b1e29635e7a7bff479697ecf9">draw()</a> method.<p>
Some systems don't allow drawing in the front buffer. In this case the entire back buffer is redrawn and the overlay drawn atop it.<p>
The default version draws a red rectangle, so that mistaken calls to <a class="el" href="classfltk_1_1Window.html#d0c83f563ac13bb59a88f0e82a7144f9">redraw_overlay()</a> are detectable.     </td>
  </tr>
</table>
<a class="anchor" name="054bedf0b81483179f715b1a60ccc553"></a><!-- doxytag: member="fltk::Window::erase_overlay" ref="054bedf0b81483179f715b1a60ccc553" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Window::erase_overlay           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Indicate that the overlay drawn with <a class="el" href="classfltk_1_1Window.html#3e4c48e061072f4a71212dcb5b7f606d">draw_overlay()</a> is blank. <a class="el" href="classfltk_1_1Window.html#3e4c48e061072f4a71212dcb5b7f606d">draw_overlay()</a> will not be called until <a class="el" href="classfltk_1_1Window.html#d0c83f563ac13bb59a88f0e82a7144f9">redraw_overlay()</a> is called again.     </td>
  </tr>
</table>
<a class="anchor" name="b79e6f93410599b39e0aa685e64cbc56"></a><!-- doxytag: member="fltk::Window::exec" ref="b79e6f93410599b39e0aa685e64cbc56" args="(const Window *parent=0, bool grab=false)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool Window::exec           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classfltk_1_1Window.html">Window</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>grab</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The window is popped up and this function does not return until <a class="el" href="classfltk_1_1Window.html#bb62d38f4a880bdc884a3434b7a82bbe">make_exec_return()</a> is called, or the window is destroyed or <a class="el" href="classfltk_1_1Widget.html#4a2f8eebacdd20db505b838f1a118c6b">hide()</a> is called, or fltk::exit_modal() is called. During this time events to other windows in this application are either thrown away or redirected to this window.<p>
This does child_of(parent) (using first() if parent is null), so this window is a floating panel that is kept above the parent. It then uses fltk::modal(this,grab) to make all events go to this window.<p>
The return value is the argument to <a class="el" href="classfltk_1_1Window.html#bb62d38f4a880bdc884a3434b7a82bbe">make_exec_return()</a>, or false if any other method is used to exit the loop.<p>
If parent is null the window that last received an event is used as the parent. This is convenient for popups that appear in response to a mouse or key click.<p>
See fltk::modal() for what grab does. This is useful for popup menus.     </td>
  </tr>
</table>
<a class="anchor" name="6ce31a8f940610315a678b4d9b9041c5"></a><!-- doxytag: member="fltk::Window::handle" ref="6ce31a8f940610315a678b4d9b9041c5" args="(int)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Window::handle           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>event</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calls <a class="el" href="group__events.html#gd3f7a1a4cec79dd682615c7e8792dbe6">send()</a> on some or all of the children widgets. 
<p>
Reimplemented from <a class="el" href="classfltk_1_1Group.html#3a7b14a10a2a6f640abeaa06daa10d72">fltk::Group</a>.    </td>
  </tr>
</table>
<a class="anchor" name="f8ee0dd02ba228e8e6170d2a4217ed18"></a><!-- doxytag: member="fltk::Window::iconlabel" ref="f8ee0dd02ba228e8e6170d2a4217ed18" args="(const char *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Window::iconlabel           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>iname</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the text displayed below the icon (or in the taskbar). If you don't set this it defaults to the label() but if that appears to be a filename, it defaults to the last portion after the last '/' character.     </td>
  </tr>
</table>
<a class="anchor" name="4c27350d7dc01d2afe45739e5b0fb4d4"></a><!-- doxytag: member="fltk::Window::label" ref="4c27350d7dc01d2afe45739e5b0fb4d4" args="(const char *)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Window::label           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the window title, which is drawn in the titlebar by the system. 
<p>
Reimplemented from <a class="el" href="classfltk_1_1Widget.html#109321fe37d81d748afaf3054d91e22f">fltk::Widget</a>.    </td>
  </tr>
</table>
<a class="anchor" name="b93968c0acfba057731631d87dbfffb8"></a><!-- doxytag: member="fltk::Window::layout" ref="b93968c0acfba057731631d87dbfffb8" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void fltk::Window::layout           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Virtual function to respond to <a class="el" href="group__layout.html#g89b38805c2f1106773619e935b0ef394">layout_damage()</a>, it should calculate the correct size of this widget and all it's children. This function is called by fltk or by the <a class="el" href="classfltk_1_1Window.html#b93968c0acfba057731631d87dbfffb8">layout()</a> method in other widgets. User programs should not call it.<p>
A widget is allowed to alter it's own size in a <a class="el" href="classfltk_1_1Window.html#b93968c0acfba057731631d87dbfffb8">layout()</a> method, to indicate a size that the data will fit in. A parent widget is then expected to rearrange itself to accomodate the new size. This may mean it will move the widget and thus <a class="el" href="classfltk_1_1Window.html#b93968c0acfba057731631d87dbfffb8">layout()</a> will be called again.<p>
You can look at <a class="el" href="group__layout.html#g89b38805c2f1106773619e935b0ef394">layout_damage()</a> to find out why this is being called.<p>
The base class redraws the widget and sets <a class="el" href="group__layout.html#g89b38805c2f1106773619e935b0ef394">layout_damage()</a> to zero. 
<p>
Reimplemented from <a class="el" href="classfltk_1_1Group.html#fecb0de3e27cb2030a4bf4cd3af704cd">fltk::Group</a>.    </td>
  </tr>
</table>
<a class="anchor" name="bb62d38f4a880bdc884a3434b7a82bbe"></a><!-- doxytag: member="fltk::Window::make_exec_return" ref="bb62d38f4a880bdc884a3434b7a82bbe" args="(bool)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Window::make_exec_return           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>return_value</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
If <a class="el" href="classfltk_1_1Window.html#b79e6f93410599b39e0aa685e64cbc56">exec()</a> is currently being called, make it hide this window and return <em>return_value</em>.<p>
Does nothing if <a class="el" href="classfltk_1_1Window.html#b79e6f93410599b39e0aa685e64cbc56">exec()</a> is not being called.<p>
Results are undefined if the innermost <a class="el" href="classfltk_1_1Window.html#b79e6f93410599b39e0aa685e64cbc56">exec()</a> is being called on a window <em>other</em> than this one. Current behavior is to cause that exec to return false.     </td>
  </tr>
</table>
<a class="anchor" name="d0c83f563ac13bb59a88f0e82a7144f9"></a><!-- doxytag: member="fltk::Window::redraw_overlay" ref="d0c83f563ac13bb59a88f0e82a7144f9" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Window::redraw_overlay           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Indicate that the image made by <a class="el" href="classfltk_1_1Window.html#3e4c48e061072f4a71212dcb5b7f606d">draw_overlay()</a> has changed and must be drawn or redrawn. If the image is blank you should call <a class="el" href="classfltk_1_1Window.html#054bedf0b81483179f715b1a60ccc553">erase_overlay()</a>.<p>
This does nothing if the window is not <a class="el" href="classfltk_1_1Window.html#d7f0f1bcbb151182a5ec9944f766d8d5">shown()</a>, it is assummed that overlays are only drawn in response to user input.     </td>
  </tr>
</table>
<a class="anchor" name="d91da0a0939943723a27ca2bd4672627"></a><!-- doxytag: member="fltk::Window::set_double_buffer" ref="d91da0a0939943723a27ca2bd4672627" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Window::set_double_buffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
If the window is double-buffered, all drawing is done first to some offscreen image, and then copied to the screen as a single block. This eliminates blinking as the window is updated, and often the application looks faster, even if it actually is slower.     </td>
  </tr>
</table>
<a class="anchor" name="254f7246f0e788485d951758ff22660e"></a><!-- doxytag: member="fltk::Window::show" ref="254f7246f0e788485d951758ff22660e" args="(const Window *parent)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Window::show           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classfltk_1_1Window.html">Window</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>parent</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as child_of(parent); <a class="el" href="classfltk_1_1Window.html#8f986e19a11c4c97ed8e6ad3d0e648b7">show()</a>.     </td>
  </tr>
</table>
<a class="anchor" name="8f986e19a11c4c97ed8e6ad3d0e648b7"></a><!-- doxytag: member="fltk::Window::show" ref="8f986e19a11c4c97ed8e6ad3d0e648b7" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Window::show           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cause the window to become visible. It is harmless to call this multiple times.<p>
For subwindows (with a <a class="el" href="classfltk_1_1Widget.html#afcfed60392799ab3bd7124e2c707575">parent()</a>) this just causes the window to appear. Currently no guarantee about stacking order is made.<p>
For a outer window (one with no <a class="el" href="classfltk_1_1Widget.html#afcfed60392799ab3bd7124e2c707575">parent()</a>) this causes the window to appear on the screen, be de-iconized, and be raised to the top. Depending on child_of() settings of this window and of windows pointing to it, and on system and window manager settings, this may cause other windows to also be deiconized and raised, or if this window is a child_of() then this window <em>may</em> remain iconized.<p>
<em><a class="el" href="classfltk_1_1Window.html#8f986e19a11c4c97ed8e6ad3d0e648b7">Window::show()</a> is not a virtual override of <a class="el" href="classfltk_1_1Widget.html#25ff178539e226b5f30ef0335d060f2b">Widget::show()</a></em>. You can call either one. The <em>only</em> difference is that if an outer window has had <a class="el" href="classfltk_1_1Window.html#8f986e19a11c4c97ed8e6ad3d0e648b7">show()</a> called already, <a class="el" href="classfltk_1_1Window.html#8f986e19a11c4c97ed8e6ad3d0e648b7">Window::show()</a> will raise and deiconize it, while <a class="el" href="classfltk_1_1Widget.html#25ff178539e226b5f30ef0335d060f2b">Widget::show()</a> will only un-hide() it, making it appear in the same stacking order as before but not changing the iconization state (on some X window managers it will deiconize anyway).<p>
The first time this is called is when the actual "system" window (ie the X window) is created. Before that an fltk window is simply an internal data structure and is not visible outside your program. To return to the non-system-window state call <a class="el" href="classfltk_1_1Window.html#a89262ad2538473c8d7e4d8dd641849d">destroy()</a> or <a class="el" href="classfltk_1_1Window.html#245d821e6016fa1f6970ccbbedd635f6">~Window()</a>. <a class="el" href="classfltk_1_1Widget.html#4a2f8eebacdd20db505b838f1a118c6b">hide()</a> will "unmap" the system window.<p>
The first time <a class="el" href="classfltk_1_1Window.html#8f986e19a11c4c97ed8e6ad3d0e648b7">show()</a> is called on any window is when fltk will call fltk::open_display() and fltk::load_theme(), unless you have already called them. This allows these expensive operations to be deferred as long as possible, and allows fltk programs to be written that will run without an X server as long as they don't actually show a window. 
<p>
Reimplemented from <a class="el" href="classfltk_1_1Widget.html#25ff178539e226b5f30ef0335d060f2b">fltk::Widget</a>.    </td>
  </tr>
</table>
<a class="anchor" name="acf539860caedce0c1c3e02b8b4c9181"></a><!-- doxytag: member="fltk::Window::show_inside" ref="acf539860caedce0c1c3e02b8b4c9181" args="(const Window *parent)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Window::show_inside           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classfltk_1_1Window.html">Window</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>frame</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make the window with a normal system border and behavior, but place it inside the <em>frame</em> as though that was the desktop. This is what Windows calls "MDI". Typically the other window (which must already be shown) is a child window so that space can remain around it for a menu/tool bar.<p>
Notice that <a class="el" href="classfltk_1_1Widget.html#afcfed60392799ab3bd7124e2c707575">parent()</a> of the window must be zero and it will remain zero after this is called. Fltk uses a zero parent to indicate that the system is managing the window.<p>
On systems that don't support nested desktops (i.e. X) this does child_of(frame) and <a class="el" href="classfltk_1_1Window.html#8f986e19a11c4c97ed8e6ad3d0e648b7">show()</a>, which produces an overlapping window that will remain above the frame window. (IMHO this is a great improvement over MDI!).     </td>
  </tr>
</table>
<a class="anchor" name="d7f0f1bcbb151182a5ec9944f766d8d5"></a><!-- doxytag: member="fltk::Window::shown" ref="d7f0f1bcbb151182a5ec9944f766d8d5" args="() const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool Window::shown           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns non-zero if <a class="el" href="classfltk_1_1Window.html#8f986e19a11c4c97ed8e6ad3d0e648b7">show()</a> has been called, but <a class="el" href="classfltk_1_1Window.html#a89262ad2538473c8d7e4d8dd641849d">destroy()</a> has not been called. Note that this returns true if <a class="el" href="classfltk_1_1Widget.html#4a2f8eebacdd20db505b838f1a118c6b">hide()</a> was called or if the user has iconized the window.     </td>
  </tr>
</table>
<a class="anchor" name="de0132a93387e62212ce3cb0bc419682"></a><!-- doxytag: member="fltk::Window::size_range" ref="de0132a93387e62212ce3cb0bc419682" args="(int a, int b, int c=0, int d=0, int e=0, int f=0)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Window::size_range           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>minw</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>minh</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>maxw</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>maxh</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>dw</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>dh</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the allowable range the user can resize this window to. This only works for top-level windows.<ul>
<li><em>minw</em> and <em>minh</em> are the smallest the window can be.</li><li><em>maxw</em> and <em>maxh</em> are the largest the window can be. If either is equal to the minimum then you cannot resize in that direction. If either is zero then FLTK picks a maximum size in that direction such that the window will fill the screen.</li><li><em>dw</em> and <em>dh</em> are size increments. The window will be constrained to widths of minw+N*dw, where N is any non-negative integer. If these are less or equal to 1 they are ignored. (this is ignored on WIN32)</li></ul>
<p>
It is undefined what happens if the current size does not fit in the constraints passed to <a class="el" href="classfltk_1_1Window.html#de0132a93387e62212ce3cb0bc419682">size_range()</a>.<p>
If this function is not called, FLTK tries to figure out the range from the setting of resizeable():<ul>
<li>If resizeable() is NULL (this is the default) then the window cannot be resized.</li><li>If either dimension of resizeable() is less than 100, then that is considered the minimum size. Otherwise the resizeable() has a minimum size of 100.</li><li>If either dimension of resizeable() is zero, then that is also the maximum size (so the window cannot resize in that direction). </li></ul>
    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="5285934f97d4416b5f6d7efd62982bff"></a><!-- doxytag: member="fltk::Window::default_style" ref="5285934f97d4416b5f6d7efd62982bff" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">NamedStyle * <a class="el" href="classfltk_1_1Window.html#5285934f97d4416b5f6d7efd62982bff">Window::default_style</a> = &amp;::style<code> [static]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
By default a window has box() set to <code>FLAT_BOX</code>, and the color() set to <code>GRAY75</code>, which is a special color cell that is altered by fltk::set_background().<p>
If you plan to turn the border() off you may want to change the box() to <code>UP_BOX</code>. You can also produce something that looks like an arbitrary shape (though really it is showing the original screen contents in the "outside" area, so the window had better be temporary and the user cannot move it) by setting the box() to <code>NO_BOX</code> and making <a class="el" href="classfltk_1_1Window.html#2ec96f7b1e29635e7a7bff479697ecf9">draw()</a> only draw the opaque part. 
<p>
Reimplemented from <a class="el" href="classfltk_1_1Widget.html">fltk::Widget</a>.    </td>
  </tr>
</table>
</html>
<body>
<hr>
<em>Tue Jun 27 02:19:54 2006. <a href="http://fltkdock.sourceforge.net"><strong>FLTK Dock</strong></a> is copyright &#169; 2006 by MD. Z. Hossain</em>
</body>
</html>
